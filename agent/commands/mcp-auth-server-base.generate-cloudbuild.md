# Command: generate-cloudbuild

> **ğŸ¤– Agent Directive**: If you are reading this file, the command `@mcp-auth-server-base.generate-cloudbuild` has been invoked. Follow the steps below to execute this command.

**Namespace**: mcp-auth-server-base
**Version**: 1.0.0
**Created**: 2026-02-22
**Last Updated**: 2026-02-22
**Status**: Active

---

**Purpose**: Generate or regenerate cloudbuild.yaml configuration for Google Cloud Build CI/CD pipeline
**Category**: Generation
**Frequency**: As Needed

---

## What This Command Does

This command generates a cloudbuild.yaml configuration file for automated CI/CD with Google Cloud Build:

1. **cloudbuild.yaml** - Complete CI/CD pipeline configuration with build, test, push, and deploy steps

**Use this when**:
- Setting up automated CI/CD pipeline
- Configuring Cloud Build for the first time
- Regenerating configuration after changes
- Adding test steps to existing pipeline
- Setting up multi-environment deployments

---

## Prerequisites

- [ ] Project initialized (package.json exists)
- [ ] Dockerfile.production exists
- [ ] Google Cloud Project configured
- [ ] Cloud Build API enabled
- [ ] Container Registry or Artifact Registry configured

---

## Steps

### 1. Verify Project Structure

Check that the project has the necessary files for Cloud Build.

**Actions**:
```bash
# Check for required files
ls -la package.json Dockerfile.production

# Check for Cloud Build configuration
gcloud config get-value project
```

**Expected Outcome**: Project structure verified

**Troubleshooting**:
- If Dockerfile.production missing: Run `@mcp-auth-server-base.generate-dockerfile` first
- If gcloud not configured: Run `gcloud init` to set up project
- If Cloud Build API not enabled: Enable it in Google Cloud Console

### 2. Gather Configuration

Collect information needed for cloudbuild.yaml.

**Actions**:
Ask user for:
1. **Service name** (e.g., "my-mcp-server")
2. **Region** (default: us-central1)
3. **Include tests?** (yes/no)
4. **Multi-environment?** (yes/no - dev/staging/prod)
5. **Secrets to mount** (comma-separated list)

**Expected Outcome**: Configuration gathered

**Defaults**:
- Service name: From package.json name field
- Region: us-central1
- Include tests: yes
- Multi-environment: no
- Secrets: PLATFORM_SERVICE_TOKEN, JWT_SECRET

### 3. Check for Existing File

Check if cloudbuild.yaml already exists.

**Actions**:
```bash
# Check for existing file
ls -la cloudbuild.yaml 2>/dev/null || true
```

**If file exists**:
- Display warning: "âš ï¸  cloudbuild.yaml already exists. Overwriting will replace current configuration."
- Show current file size and modification date
- Ask for confirmation: "Continue and overwrite? (y/n)"
- If no: Exit gracefully
- If yes: Proceed with generation

**Expected Outcome**: Overwrite confirmed or generation cancelled

### 4. Generate cloudbuild.yaml

Create the cloudbuild.yaml file with appropriate configuration.

**Actions**:
Create `cloudbuild.yaml` with content based on user selections:

**Basic Configuration** (no tests, single environment):
```yaml
# cloudbuild.yaml
# Generated by @mcp-auth-server-base.generate-cloudbuild

steps:
  # Build Docker image
  - name: 'gcr.io/cloud-builders/docker'
    args:
      - 'build'
      - '-f'
      - 'Dockerfile.production'
      - '-t'
      - 'gcr.io/${PROJECT_ID}/${_SERVICE_NAME}:${SHORT_SHA}'
      - '-t'
      - 'gcr.io/${PROJECT_ID}/${_SERVICE_NAME}:latest'
      - '--build-arg'
      - 'BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")'
      - '--build-arg'
      - 'VERSION=${TAG_NAME}'
      - '--build-arg'
      - 'REVISION=${SHORT_SHA}'
      - '.'

  # Push images to Container Registry
  - name: 'gcr.io/cloud-builders/docker'
    args:
      - 'push'
      - '--all-tags'
      - 'gcr.io/${PROJECT_ID}/${_SERVICE_NAME}'

  # Deploy to Cloud Run
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    entrypoint: gcloud
    args:
      - 'run'
      - 'deploy'
      - '${_SERVICE_NAME}'
      - '--image=gcr.io/${PROJECT_ID}/${_SERVICE_NAME}:${SHORT_SHA}'
      - '--region=${_REGION}'
      - '--platform=managed'
      - '--allow-unauthenticated'
      # Resource limits
      - '--memory=512Mi'
      - '--cpu=1'
      - '--timeout=60s'
      - '--max-instances=10'
      - '--min-instances=0'
      # Environment variables
      - '--set-env-vars=NODE_ENV=production'
      - '--set-env-vars=PORT=8080'
      # Secrets from Secret Manager
      - '--update-secrets=PLATFORM_SERVICE_TOKEN=${_SERVICE_NAME}-platform-token:latest'
      - '--update-secrets=JWT_SECRET=${_SERVICE_NAME}-jwt-secret:latest'

# Substitution variables
substitutions:
  _SERVICE_NAME: my-mcp-server
  _REGION: us-central1

# Images to store in Container Registry
images:
  - 'gcr.io/${PROJECT_ID}/${_SERVICE_NAME}:${SHORT_SHA}'
  - 'gcr.io/${PROJECT_ID}/${_SERVICE_NAME}:latest'

# Build timeout (20 minutes)
timeout: '1200s'

# Build options
options:
  machineType: 'N1_HIGHCPU_8'
  logging: CLOUD_LOGGING_ONLY
```

**With Tests**:
Add these steps before the Docker build step:
```yaml
  # Install dependencies
  - name: 'node:20-alpine'
    entrypoint: npm
    args: ['ci']

  # Run type checking
  - name: 'node:20-alpine'
    entrypoint: npm
    args: ['run', 'type-check']

  # Run tests
  - name: 'node:20-alpine'
    entrypoint: npm
    args: ['test']
    env:
      - 'NODE_ENV=test'
```

**Multi-Environment**:
Replace deploy step with conditional deployment:
```yaml
  # Deploy to staging (on develop branch)
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    entrypoint: bash
    args:
      - '-c'
      - |
        if [ "${BRANCH_NAME}" = "develop" ]; then
          gcloud run deploy ${_SERVICE_NAME}-staging \
            --image=gcr.io/${PROJECT_ID}/${_SERVICE_NAME}:${SHORT_SHA} \
            --region=${_REGION} \
            --platform=managed \
            --allow-unauthenticated \
            --memory=512Mi \
            --cpu=1 \
            --set-env-vars=NODE_ENV=staging \
            --update-secrets=PLATFORM_SERVICE_TOKEN=${_SERVICE_NAME}-staging-platform-token:latest \
            --update-secrets=JWT_SECRET=${_SERVICE_NAME}-staging-jwt-secret:latest
        fi

  # Deploy to production (on main branch)
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    entrypoint: bash
    args:
      - '-c'
      - |
        if [ "${BRANCH_NAME}" = "main" ]; then
          gcloud run deploy ${_SERVICE_NAME} \
            --image=gcr.io/${PROJECT_ID}/${_SERVICE_NAME}:${SHORT_SHA} \
            --region=${_REGION} \
            --platform=managed \
            --allow-unauthenticated \
            --memory=512Mi \
            --cpu=1 \
            --set-env-vars=NODE_ENV=production \
            --update-secrets=PLATFORM_SERVICE_TOKEN=${_SERVICE_NAME}-platform-token:latest \
            --update-secrets=JWT_SECRET=${_SERVICE_NAME}-jwt-secret:latest
        fi
```

**Expected Outcome**: cloudbuild.yaml created

**Verification**:
```bash
# Verify file created
ls -la cloudbuild.yaml

# Validate YAML syntax
gcloud builds submit --config=cloudbuild.yaml --no-source --dry-run
```

### 5. Display Generation Summary

Show what was generated and next steps.

**Actions**:
Display summary:

```
âœ… Cloud Build Configuration Generated

File Created:
  âœ“ cloudbuild.yaml (complete CI/CD pipeline)

Configuration:
  â€¢ Service: my-mcp-server
  â€¢ Region: us-central1
  â€¢ Tests: Included
  â€¢ Environments: Single (production)
  â€¢ Machine Type: N1_HIGHCPU_8
  â€¢ Timeout: 20 minutes

Pipeline Steps:
  1. Install dependencies (npm ci)
  2. Run type checking (npm run type-check)
  3. Run tests (npm test)
  4. Build Docker image (multi-stage)
  5. Push to Container Registry (SHA + latest tags)
  6. Deploy to Cloud Run (with secrets)

Next Steps:
  1. Update substitution variables in cloudbuild.yaml:
     - _SERVICE_NAME: your-service-name
     - _REGION: your-region

  2. Ensure secrets exist in Secret Manager:
     gcloud secrets list

  3. Test build locally (optional):
     gcloud builds submit --config=cloudbuild.yaml

  4. Create Cloud Build trigger:
     gcloud builds triggers create github \
       --repo-name=your-repo \
       --repo-owner=your-org \
       --branch-pattern="^main$" \
       --build-config=cloudbuild.yaml

  5. Push to trigger build:
     git push origin main

Related Commands:
  â€¢ @mcp-auth-server-base.setup-secrets - Set up secrets
  â€¢ @mcp-auth-server-base.deploy - Manual deployment
  â€¢ @mcp-auth-server-base.validate - Validate configuration

Related Patterns:
  â€¢ agent/patterns/mcp-auth-server-base.cloud-build.md
  â€¢ agent/patterns/mcp-auth-server-base.cloud-run-deployment.md
  â€¢ agent/patterns/mcp-auth-server-base.secrets-management.md
```

**Expected Outcome**: Summary displayed

---

## Customization Options

### Option 1: Custom Machine Type

**Default**: N1_HIGHCPU_8

**To customize**:
1. Edit cloudbuild.yaml
2. Change `machineType` in options section
3. Available types: E2_HIGHCPU_8, N1_HIGHCPU_32, etc.

**Example**:
```yaml
options:
  machineType: 'E2_HIGHCPU_8'  # More cost-effective
```

### Option 2: Custom Timeout

**Default**: 1200s (20 minutes)

**To customize**:
1. Edit cloudbuild.yaml
2. Change `timeout` value
3. Maximum: 86400s (24 hours)

**Example**:
```yaml
timeout: '1800s'  # 30 minutes
```

### Option 3: Add Docker Layer Caching

**To enable caching**:
Add pull step before build:

```yaml
steps:
  # Pull previous image for cache
  - name: 'gcr.io/cloud-builders/docker'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        docker pull gcr.io/${PROJECT_ID}/${_SERVICE_NAME}:latest || exit 0

  # Build with cache
  - name: 'gcr.io/cloud-builders/docker'
    args:
      - 'build'
      - '--cache-from'
      - 'gcr.io/${PROJECT_ID}/${_SERVICE_NAME}:latest'
      - '-t'
      - 'gcr.io/${PROJECT_ID}/${_SERVICE_NAME}:${SHORT_SHA}'
      - '.'
```

**Benefit**: Faster builds (30-50% reduction)

### Option 4: Add Vulnerability Scanning

**To enable scanning**:
Add scan step after build:

```yaml
  # Scan image for vulnerabilities
  - name: 'gcr.io/cloud-builders/gcloud'
    args:
      - 'container'
      - 'images'
      - 'scan'
      - 'gcr.io/${PROJECT_ID}/${_SERVICE_NAME}:${SHORT_SHA}'
```

### Option 5: Add Notifications

**To add Slack notifications**:
Add notification step:

```yaml
  # Send success notification
  - name: 'gcr.io/cloud-builders/curl'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        curl -X POST ${_SLACK_WEBHOOK} \
          -H 'Content-Type: application/json' \
          -d '{"text":"âœ… Build ${BUILD_ID} succeeded for ${_SERVICE_NAME}"}'

substitutions:
  _SLACK_WEBHOOK: https://hooks.slack.com/services/YOUR/WEBHOOK/URL
```

### Option 6: Add Manual Approval

**For production deployments**:
Split into staging and production with approval:

```yaml
  # Deploy to staging
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    entrypoint: gcloud
    args:
      - 'run'
      - 'deploy'
      - '${_SERVICE_NAME}-staging'
      - '--image=gcr.io/${PROJECT_ID}/${_SERVICE_NAME}:${SHORT_SHA}'
      - '--region=${_REGION}'

  # Manual approval required here (configure in Cloud Build UI)

  # Deploy to production
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    entrypoint: gcloud
    args:
      - 'run'
      - 'deploy'
      - '${_SERVICE_NAME}'
      - '--image=gcr.io/${PROJECT_ID}/${_SERVICE_NAME}:${SHORT_SHA}'
      - '--region=${_REGION}'
```

---

## Examples

### Example 1: Generate Basic Pipeline

**Scenario**: First-time setup, single environment

**Invocation**: `@mcp-auth-server-base.generate-cloudbuild`

**Workflow**:
```
Agent: "Service name (from package.json: my-mcp-server)?"
User: "my-mcp-server"

Agent: "Region (default: us-central1)?"
User: "us-central1"

Agent: "Include tests in pipeline? (y/n)"
User: "y"

Agent: "Multi-environment deployment? (y/n)"
User: "n"

Agent: "Secrets to mount (comma-separated, default: PLATFORM_SERVICE_TOKEN,JWT_SECRET)?"
User: "[Enter]"

Agent: "Generating cloudbuild.yaml..."

âœ… Generated cloudbuild.yaml (basic pipeline with tests)

Next: Update substitutions and create Cloud Build trigger
```

### Example 2: Generate Multi-Environment Pipeline

**Scenario**: Need staging and production environments

**Invocation**: `@mcp-auth-server-base.generate-cloudbuild`

**Workflow**:
```
Agent: "Multi-environment deployment? (y/n)"
User: "y"

Agent: "Generating cloudbuild.yaml with multi-environment support..."

âœ… Generated cloudbuild.yaml
  â€¢ develop branch â†’ staging environment
  â€¢ main branch â†’ production environment

Next: Create separate secrets for staging and production
```

### Example 3: Regenerate with Different Configuration

**Scenario**: Existing cloudbuild.yaml, want to add tests

**Invocation**: `@mcp-auth-server-base.generate-cloudbuild`

**Workflow**:
```
Agent: "âš ï¸  cloudbuild.yaml already exists. Overwrite? (y/n)"
User: "y"

Agent: "Include tests in pipeline? (y/n)"
User: "y"

Agent: "Regenerating cloudbuild.yaml with test steps..."

âœ… Regenerated cloudbuild.yaml (now includes npm test)
```

---

## Verification

After generating cloudbuild.yaml, verify it works correctly:

### 1. Validate YAML Syntax

```bash
# Dry run to validate syntax
gcloud builds submit --config=cloudbuild.yaml --no-source --dry-run

# Should output: "Dry run successful"
```

### 2. Test Build Locally

```bash
# Install cloud-build-local (if not installed)
gcloud components install cloud-build-local

# Run build locally
cloud-build-local --config=cloudbuild.yaml \
  --dryrun=false \
  --substitutions=_SERVICE_NAME=my-app,_REGION=us-central1 \
  .
```

### 3. Submit Test Build

```bash
# Submit to Cloud Build
gcloud builds submit \
  --config=cloudbuild.yaml \
  --substitutions=_SERVICE_NAME=my-mcp-server,_REGION=us-central1

# Monitor build progress
gcloud builds log --stream
```

### 4. Create Trigger

```bash
# Create GitHub trigger
gcloud builds triggers create github \
  --repo-name=my-repo \
  --repo-owner=my-org \
  --branch-pattern="^main$" \
  --build-config=cloudbuild.yaml \
  --substitutions=_SERVICE_NAME=my-mcp-server,_REGION=us-central1
```

### 5. Test Trigger

```bash
# Push to trigger build
git add cloudbuild.yaml
git commit -m "Add Cloud Build configuration"
git push origin main

# Watch build in Cloud Console
# https://console.cloud.google.com/cloud-build/builds
```

---

## Checklist

- [ ] Project structure verified
- [ ] Configuration gathered
- [ ] Existing file checked
- [ ] cloudbuild.yaml generated
- [ ] Substitutions updated
- [ ] YAML syntax validated
- [ ] Secrets verified in Secret Manager
- [ ] Test build submitted
- [ ] Trigger created
- [ ] Pipeline tested end-to-end

---

## Expected Output

### Console Output

```
ğŸ—ï¸  Generating Cloud Build Configuration

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Step 1: Verifying Project Structure

âœ“ package.json found
âœ“ Dockerfile.production found
âœ“ Google Cloud project configured (my-project-123)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Step 2: Gathering Configuration

Service name: my-mcp-server
Region: us-central1
Include tests: yes
Multi-environment: no
Secrets: PLATFORM_SERVICE_TOKEN, JWT_SECRET

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Step 3: Generating cloudbuild.yaml

âœ“ Generated cloudbuild.yaml (156 lines)

Pipeline Steps:
  1. Install dependencies
  2. Run type checking
  3. Run tests
  4. Build Docker image
  5. Push to Container Registry
  6. Deploy to Cloud Run

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

âœ… Cloud Build Configuration Complete

Next Steps:

1. Validate configuration:
   gcloud builds submit --config=cloudbuild.yaml --no-source --dry-run

2. Create Cloud Build trigger:
   gcloud builds triggers create github \
     --repo-name=my-repo \
     --repo-owner=my-org \
     --branch-pattern="^main$" \
     --build-config=cloudbuild.yaml

3. Push to trigger build:
   git add cloudbuild.yaml
   git commit -m "Add Cloud Build configuration"
   git push origin main

Related Commands:
  â€¢ @mcp-auth-server-base.setup-secrets
  â€¢ @mcp-auth-server-base.deploy
  â€¢ @mcp-auth-server-base.validate

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
```

---

## Troubleshooting

### Issue 1: YAML syntax error

**Symptom**: Error "invalid YAML syntax"

**Cause**: Malformed YAML (indentation, special characters)

**Solution**:
```bash
# Validate YAML
gcloud builds submit --config=cloudbuild.yaml --no-source --dry-run

# Check indentation (must be 2 spaces)
# Check for tabs (not allowed in YAML)
# Check for special characters in strings
```

### Issue 2: Substitution variable not found

**Symptom**: Error "substitution variable _SERVICE_NAME not defined"

**Cause**: Variable used but not defined in substitutions section

**Solution**:
```yaml
# Add to substitutions section
substitutions:
  _SERVICE_NAME: my-mcp-server
  _REGION: us-central1
```

### Issue 3: Secret not found

**Symptom**: Error "secret not found: my-app-platform-token"

**Cause**: Secret doesn't exist in Secret Manager

**Solution**:
```bash
# List secrets
gcloud secrets list

# Create missing secret
gcloud secrets create my-app-platform-token \
  --data-file=- <<< "your-secret-value"

# Or run setup-secrets command
@mcp-auth-server-base.setup-secrets
```

### Issue 4: Build timeout

**Symptom**: Build fails with "timeout exceeded"

**Cause**: Build takes longer than timeout setting

**Solution**:
```yaml
# Increase timeout in cloudbuild.yaml
timeout: '1800s'  # 30 minutes instead of 20

# Or optimize build:
# - Use layer caching
# - Use faster machine type
# - Reduce test suite
```

### Issue 5: Permission denied

**Symptom**: Error "permission denied" during deploy

**Cause**: Cloud Build service account lacks permissions

**Solution**:
```bash
# Grant Cloud Run Admin role
PROJECT_NUMBER=$(gcloud projects describe $(gcloud config get-value project) --format='value(projectNumber)')
gcloud projects add-iam-policy-binding $(gcloud config get-value project) \
  --member=serviceAccount:${PROJECT_NUMBER}@cloudbuild.gserviceaccount.com \
  --role=roles/run.admin

# Grant Service Account User role
gcloud projects add-iam-policy-binding $(gcloud config get-value project) \
  --member=serviceAccount:${PROJECT_NUMBER}@cloudbuild.gserviceaccount.com \
  --role=roles/iam.serviceAccountUser
```

### Issue 6: Image push fails

**Symptom**: Error "denied: Permission denied for image"

**Cause**: Cloud Build service account can't push to Container Registry

**Solution**:
```bash
# Grant Storage Admin role for Container Registry
PROJECT_NUMBER=$(gcloud projects describe $(gcloud config get-value project) --format='value(projectNumber)')
gcloud projects add-iam-policy-binding $(gcloud config get-value project) \
  --member=serviceAccount:${PROJECT_NUMBER}@cloudbuild.gserviceaccount.com \
  --role=roles/storage.admin
```

### Issue 7: Tests fail in pipeline

**Symptom**: Build fails at test step

**Cause**: Tests pass locally but fail in Cloud Build

**Solution**:
```yaml
# Add test environment variables
steps:
  - name: 'node:20-alpine'
    entrypoint: npm
    args: ['test']
    env:
      - 'NODE_ENV=test'
      - 'CI=true'
      # Add any other required env vars
```

### Issue 8: Slow builds

**Symptom**: Builds take > 10 minutes

**Cause**: No layer caching, slow machine type

**Solution**:
```yaml
# Add layer caching (see Option 3 above)
# Use faster machine
options:
  machineType: 'N1_HIGHCPU_32'  # Faster but more expensive

# Or optimize Dockerfile
# - Combine RUN commands
# - Order layers by change frequency
# - Use smaller base images
```

---

## Advanced Usage

### Parallel Steps

Run independent steps in parallel:

```yaml
steps:
  # These steps run in parallel
  - name: 'node:20-alpine'
    id: 'lint'
    entrypoint: npm
    args: ['run', 'lint']
    waitFor: ['-']  # Start immediately

  - name: 'node:20-alpine'
    id: 'test'
    entrypoint: npm
    args: ['test']
    waitFor: ['-']  # Start immediately

  # This waits for both
  - name: 'gcr.io/cloud-builders/docker'
    args: ['build', '-t', 'my-app', '.']
    waitFor: ['lint', 'test']
```

### Conditional Steps

Run steps based on conditions:

```yaml
steps:
  # Only run on main branch
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    entrypoint: bash
    args:
      - '-c'
      - |
        if [ "${BRANCH_NAME}" = "main" ]; then
          echo "Deploying to production"
          gcloud run deploy my-app --image=...
        else
          echo "Skipping production deployment"
        fi
```

### Build Matrix

Test multiple Node versions:

```yaml
steps:
  # Test on Node 18
  - name: 'node:18-alpine'
    entrypoint: npm
    args: ['test']

  # Test on Node 20
  - name: 'node:20-alpine'
    entrypoint: npm
    args: ['test']

  # Test on Node 22
  - name: 'node:22-alpine'
    entrypoint: npm
    args: ['test']
```

### Custom Builder

Use custom Docker image as builder:

```yaml
steps:
  - name: 'gcr.io/${PROJECT_ID}/my-custom-builder'
    args: ['custom-build-command']
```

---

## Security Considerations

### 1. Never Hardcode Secrets

**âŒ WRONG**:
```yaml
args:
  - '--set-env-vars=JWT_SECRET=my-secret-key'
```

**âœ… CORRECT**:
```yaml
args:
  - '--update-secrets=JWT_SECRET=my-app-jwt-secret:latest'
```

### 2. Use Specific Image Tags

**âŒ WRONG**:
```yaml
- name: 'node:latest'  # Unpredictable
```

**âœ… CORRECT**:
```yaml
- name: 'node:20-alpine'  # Specific version
```

### 3. Scan Images

```yaml
# Add vulnerability scanning
- name: 'gcr.io/cloud-builders/gcloud'
  args:
    - 'container'
    - 'images'
    - 'scan'
    - 'gcr.io/${PROJECT_ID}/${_SERVICE_NAME}:${SHORT_SHA}'
```

### 4. Minimal Permissions

Grant only necessary IAM roles to Cloud Build service account.

### 5. Private Registry

Use private Container Registry or Artifact Registry.

### 6. Audit Logging

Enable Cloud Build audit logs for compliance.

---

## Related Commands

- [`@mcp-auth-server-base.init`](mcp-auth-server-base.init.md) - Includes cloudbuild.yaml generation
- [`@mcp-auth-server-base.deploy`](mcp-auth-server-base.deploy.md) - Manual deployment alternative
- [`@mcp-auth-server-base.setup-secrets`](mcp-auth-server-base.setup-secrets.md) - Set up secrets for pipeline
- [`@mcp-auth-server-base.generate-dockerfile`](mcp-auth-server-base.generate-dockerfile.md) - Generate Dockerfiles first
- [`@mcp-auth-server-base.validate`](mcp-auth-server-base.validate.md) - Validate configuration

---

## Related Patterns

- [`mcp-auth-server-base.cloud-build`](../patterns/mcp-auth-server-base.cloud-build.md) - Cloud Build pattern
- [`mcp-auth-server-base.cloud-run-deployment`](../patterns/mcp-auth-server-base.cloud-run-deployment.md) - Cloud Run deployment
- [`mcp-auth-server-base.secrets-management`](../patterns/mcp-auth-server-base.secrets-management.md) - Secrets management
- [`mcp-auth-server-base.docker-multistage`](../patterns/mcp-auth-server-base.docker-multistage.md) - Docker builds

---

## Notes

- **Overwrite Warning**: Always warn before overwriting existing cloudbuild.yaml
- **Substitutions**: Clearly document all substitution variables
- **Secrets**: Reference secrets from Secret Manager, never hardcode
- **Testing**: Include test steps for quality assurance
- **Multi-Environment**: Support staging and production deployments
- **Validation**: Validate YAML syntax before committing
- **Triggers**: Document how to create Cloud Build triggers
- **Permissions**: Ensure Cloud Build service account has necessary permissions

---

**Namespace**: mcp-auth-server-base
**Command**: generate-cloudbuild
**Version**: 1.0.0
**Created**: 2026-02-22
**Last Updated**: 2026-02-22
**Status**: Active
**Compatibility**: ACP 3.7.0+
**Author**: mcp-auth-server-base Package
